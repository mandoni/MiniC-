package analizador;
//Sintactico.symbolTable.put(lexeme, new symbol("name", "tipo", ambito))
//Java Libraries
import java.util.ArrayList;
import java_cup.runtime.Symbol;
import java.util.Hashtable;
import java.util.List;

parser code {:
    public static Hashtable<String, symbol> symbolTable = new Hashtable<String, symbol>();
    public static List<logs> Log = new  ArrayList<logs>();

    public static int context = 0, cMin = 0, ambito = 0;
    public static String parametros = "";

    
    public ArrayList<String> SyntacticErrors = new ArrayList<String>();
    public int count = 0;

    public void syntax_error(Symbol cur_token){
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) cur_token);
        System.out.println("\033[31m*** Error Sintactico. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
        SyntacticErrors.add("\033[31m*** Error Sintactico. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
    }

    public void unrecovered_syntax_error(Symbol cur_token){
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) cur_token);
        System.out.println("\033[31m*** Error Sintactico No Recuperado. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
        SyntacticErrors.add("\033[31m1*** Error Sintactico No Recuperado. Linea: " + (s.left+1) + " Columna: " + (s.right+1) + ". Simbolo: \'" + s.value + "\' *** Mensaje Error: Simbolo no reconocido.");
    }

    public Hashtable<String, symbol> getHashTable(){
         return symbolTable;
     }
     
     public List<logs> getLog (){
         return Log;
     }
:}

/*  Symbol Lists  */

// Terminals
terminal    pyc, INT, DOUBLE, BOOL, STRING, OpeningBracket, ClosedBracket, OpeningParenthesis, ClosedParenthesis, sVoid, comma, sClass, OpeningCurlyBracket, ClosedCurlyBracket, sExtends, sImplements, sInterface,
cIf, cElse, lWhile, lFor, sReturn, sBreak, sPrint, assignment, sThis, sNew, sNewArray, sReadInteger, sMalloc, dot, sGetByte, sSetByte, sNull, sReadLine, boolConstant,
ComparisonOperators, equality, negative, sum, ArithmeticOperators, denial, Brackets, and, or, Parenthesis, CurlyBrackets, Constante;
terminal    Integer     integerConstant;
terminal    String      ident, stringConstant;
terminal    Double      doubleConstant; 
// Non Terminals
non terminal Program, ProgramA, Decl, VariableDecl, VariableDeclAux, Variable, Type, FunctionDecl, Formals, RepeatVariable, ClassDecl, ExtIdent, ImpIdent, MultipleIdents,
Field, RepeatableField, InterfaceDecl, Prototype, RepeatablePrototype, StmtBlock, Stmt, StmtAux, IfStmt, ElseStmt, WhileStmt, ForStmt, ReturnStmt, BreakStmt, PrintStmt, Expr, ExprOZ, 
ExprRepeat, LValue, Call, LibCall, Actuals, Constant;

/*  Precedence and Associativity declarations   */
precedence left assignment;
precedence left or,and;
precedence nonassoc ComparisonOperators,equality;
precedence left sum,negative,ArithmeticOperators;
precedence nonassoc denial;
precedence nonassoc OpeningBracket,dot;
precedence nonassoc cElse;

/* Grammar */
start with Program;

Program ::= Decl ProgramA;
ProgramA ::= ProgramA Decl| /* epsilon */;

Decl ::=  VariableDecl| 
          FunctionDecl| 
          ClassDecl| 
          InterfaceDecl| 
          error pyc| 
          error ClosedCurlyBracket;

VariableDecl ::= Variable pyc;

Variable ::= /*Constante Type:tipo ident:name assignment Constant:value 
            {:
                if(exec.AlreadyExists(Sintactico.symbolTable, name.toString(), Sintactico.ambito, Sintactico.cMin)){
                    System.out.println("\033[31m*** Error: Variable name: "+ name.toString() +" is already exists***");
                }
                else{
                    symbol s = new symbol(name, tipo.toString(), Sintactico.ambito);
                    s.constante = true; 
                    s.SymbolValue(value.toString());
                    Sintactico.symbolTable.put(name.toString(), new symbol(name.toString(), tipo.toString(), Sintactico.ambito));
                    Sintactico.Log.add(new logs("Insert", name.toString(), tipo.toString(), value.toString(), Sintactico.ambito));
                }
                RESULT = tipo;
            :}
            |*/Type:tipo ident:name
            {:
                if(exec.AlreadyExists(Sintactico.symbolTable, name.toString(), Sintactico.ambito, Sintactico.cMin)){
                    System.out.println("\033[31m*** Error: Variable name: "+ name.toString() +" is already exists***");
                }
                else{
                    Sintactico.symbolTable.put(name.toString(), new symbol(name.toString(), tipo.toString(), Sintactico.ambito));
                    Sintactico.Log.add(new logs("Insert", name.toString(), tipo.toString(), "", Sintactico.ambito));
                }
                RESULT = tipo;
            :};

Type ::=  INT                   {: RESULT = new String("int"); :}
        |DOUBLE                 {: RESULT = new String("double"); :}
        |BOOL                   {: RESULT = new String("bool"); :}
        |STRING                 {: RESULT = new String("string"); :}
        |ident:name             {: RESULT = new String(name.toString()); :}
        |Type:tipo Brackets     {: RESULT = new String(tipo.toString() + "[]"); :} 
        ;

FunctionDecl ::= Type:tipo ident:nombre OpeningParenthesis Formals:param ClosedParenthesis 
                {:
                    if(exec.ExistsFunction(Sintactico.symbolTable, nombre.toString())){
                        System.out.println("\033[31m***Error: Function name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "function", Sintactico.ambito);
                        s.AddFunction(tipo.toString(), Sintactico.parametros);
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "function", tipo.toString(), Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    }
                :}
                StmtBlock
                |sVoid ident:nombre OpeningParenthesis Formals:param ClosedParenthesis 
                    {:
                    if(exec.ExistsFunction(Sintactico.symbolTable, nombre.toString())){
                        System.out.println("\033[31m***Error: Method name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "method", Sintactico.ambito);
                        s.AddFunction("void", Sintactico.parametros);
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "method", "void", Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    }
                :}
                StmtBlock
                 
                |Type:tipo ident:nombre Parenthesis 
                {:
                    if(exec.ExistsFunction(Sintactico.symbolTable, nombre.toString())){
                        System.out.println("\033[31m***Error: Function name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "function", Sintactico.ambito);
                        s.AddFunction(tipo.toString(), Sintactico.parametros);
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "function", tipo.toString(), Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    }
                :}
                StmtBlock
                |sVoid ident:nombre Parenthesis 
                {:
                    if(exec.ExistsFunction(Sintactico.symbolTable, nombre.toString())){
                        System.out.println("\033[31m***Error: Method name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "method", Sintactico.ambito);
                        s.AddFunction("void", Sintactico.parametros);
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "method", "void", Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    }
                :}
                StmtBlock
                ;

Formals ::= Variable:tipo RepeatVariable                {: Sintactico.parametros+=tipo+"$"; RESULT = Sintactico.parametros; :}
            | /* epsilon */;                            //{: Sintactico.parametros+=""; RESULT = Sintactico.parametros; :}
RepeatVariable ::= comma Variable:tipo RepeatVariable   {: Sintactico.parametros+= tipo+"$"; RESULT = Sintactico.parametros; :}
            | /* epsilon */;                            //{: Sintactico.parametros+=""; RESULT = Sintactico.parametros; :}

ClassDecl ::= sClass ident:nombre ExtIdent ImpIdent 
            {:  
                if(exec.ExistsFunction(Sintactico.symbolTable, nombre)){
                        System.out.println("\033[31m***Error: Method name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "class", Sintactico.ambito);
                        s.AddFunction("class", "");
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "class", "", Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    } 
            :}
            OpeningCurlyBracket {: Sintactico.ambito++; :} RepeatableField ClosedCurlyBracket /*{: exec.DeleteAmbit(Sintactico.symbolTable, Sintactico.ambito); Sintactico.ambito--;  :}*/
            
            | sClass ident:nombre ExtIdent ImpIdent CurlyBrackets
            {:
                 if(exec.ExistsFunction(Sintactico.symbolTable, nombre)){
                        System.out.println("\033[31m***Error: Method name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "class", Sintactico.ambito);
                        s.AddFunction("class", "");
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "class", "", Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    } 
            :};
ExtIdent ::= sExtends ident
            | /* epsilon */;
ImpIdent ::= sImplements MultipleIdents
            | /* epsilon */;
MultipleIdents ::= ident
            |MultipleIdents comma ident;
                
RepeatableField ::= RepeatableField Field
            | /* epsilon */;

Field ::= VariableDecl 
            | FunctionDecl;

InterfaceDecl ::= sInterface ident:nombre 
                {: 
                     if(exec.ExistsFunction(Sintactico.symbolTable, nombre)){
                        System.out.println("\033[31m***Error: Interface name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "interface", Sintactico.ambito);
                        s.AddFunction("class", "");
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "interface", "", Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    } 
                :}
                OpeningCurlyBracket {: Sintactico.ambito++; :} RepeatablePrototype ClosedCurlyBracket {: exec.DeleteAmbit(Sintactico.symbolTable, Sintactico.ambito); Sintactico.ambito--; :}
                | sInterface ident:nombre 
                {: 
                     if(exec.ExistsFunction(Sintactico.symbolTable, nombre)){
                        System.out.println("\033[31m***Error: Interface name: "+ nombre.toString() +" is already exists***");
                    }
                    else{
                        symbol s = new symbol(nombre.toString(), "interface", Sintactico.ambito);
                        s.AddFunction("class", "");
                        Sintactico.symbolTable.put(nombre.toString(), s);
                        Sintactico.Log.add(new logs("Insert", nombre.toString(), "interface", "", Sintactico.parametros, Sintactico.ambito));
                        Sintactico.parametros = "";
                    } 
                :}
                CurlyBrackets;
//-----------------------------------------------------------------------------------------------------------------------------
RepeatablePrototype ::= RepeatablePrototype Prototype| /* epsilon */;
Prototype ::= Type:tipo ident:nombre OpeningParenthesis Formals ClosedParenthesis pyc
            |sVoid ident OpeningParenthesis Formals ClosedParenthesis pyc
            |Type ident Parenthesis pyc
            |sVoid ident Parenthesis pyc;

StmtBlock ::= OpeningCurlyBracket VariableDeclAux StmtAux ClosedCurlyBracket
            | CurlyBrackets;
VariableDeclAux ::= VariableDeclAux VariableDecl| /* epsilon */;
StmtAux ::= Stmt StmtAux| /* epsilon */ ;

Stmt ::= Expr pyc
        |pyc
        |IfStmt
        |WhileStmt
        |ForStmt 
        |BreakStmt
        |ReturnStmt 
        |PrintStmt 
        |StmtBlock;
ExprOZ ::= Expr| /* epsilon */ ;

IfStmt ::= cIf OpeningParenthesis Expr ClosedParenthesis Stmt ElseStmt;
ElseStmt ::= cElse Stmt| /* epsilon */ ;

WhileStmt ::= lWhile OpeningParenthesis Expr ClosedParenthesis Stmt;

ForStmt ::= lFor OpeningParenthesis ExprOZ pyc  Expr pyc ExprOZ ClosedParenthesis Stmt;

ReturnStmt ::= sReturn ExprOZ pyc;

BreakStmt ::= sBreak pyc;

PrintStmt ::= sPrint OpeningParenthesis Expr ExprRepeat ClosedParenthesis pyc;
ExprRepeat ::= comma Expr ExprRepeat| /* epsilon */ ;

Expr ::= LValue assignment Expr
        |Constant 
        |LValue 
        |sThis
        |Call 
        |OpeningParenthesis Expr ClosedParenthesis
        |Expr ArithmeticOperators Expr
        |Expr sum Expr
        |Expr negative Expr
        |Expr and Expr 
        |Expr or Expr
        |Expr equality Expr
        |Expr ComparisonOperators Expr
        |negative Expr 
        |denial Expr
        |sNew OpeningParenthesis ident ClosedParenthesis
        |sNewArray OpeningParenthesis Expr comma Type ClosedParenthesis
        |sReadInteger OpeningParenthesis ClosedParenthesis
        |sReadInteger Parenthesis
        |sReadLine Parenthesis
        |sReadLine OpeningParenthesis ClosedParenthesis
        |sMalloc OpeningParenthesis Expr ClosedParenthesis;

LValue ::= ident
           |Expr dot ident
           |Expr OpeningBracket Expr ClosedBracket;

Call ::= ident OpeningParenthesis Actuals ClosedParenthesis
        |ident Parenthesis
        |Expr dot ident OpeningParenthesis Actuals ClosedParenthesis
        |Expr dot ident Parenthesis
        |Expr dot LibCall OpeningParenthesis Actuals ClosedParenthesis
        |Expr dot LibCall Parenthesis;

LibCall ::= sGetByte OpeningParenthesis Expr ClosedParenthesis
            |sSetByte OpeningParenthesis Expr comma Expr ClosedParenthesis;

Actuals ::= Expr ExprRepeat| /* epsilon */ ;

Constant ::= integerConstant
            |doubleConstant 
            |boolConstant 
            |stringConstant 
            |sNull;